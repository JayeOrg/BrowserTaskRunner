# Rejected Approaches & Won't Fix

Decisions that have been made and should not be revisited. Check this file before proposing changes — if something is listed here, skip it silently.

## Won't Fix (DX Review)

Findings considered during DX reviews and intentionally kept as-is. Don't re-raise these.

- **Project scaffolding template (`stack/projects/_template/`)**: A skeleton README and task file for new projects was considered. New projects are created by copying an existing task file (`botcLogin.ts` is the canonical reference) and an existing project README. At 2 projects, copying is simpler than maintaining a template that drifts from the real code. The README's "Adding New Tasks" section has an inline code template, and the reviewer checklist covers the required structure.
- **`clicks.ts` CDP fallback logging**: `cdpClickAt` silently falls back to DOM click when CDP attach fails (lines 39, 59). Logging here would be noisy — CDP attach fails routinely when debugger is already attached, and the fallback is intentional. The caller already logs click results.
- **`pollUntil` uses `ok` while `SelectorResult`/`TurnstileDetectionResult` use `found`**: These are different semantic concepts. `ok` means "the operation completed successfully" (generic polling). `found` means "the element was located in the DOM" (selector queries). Using `found` for poll results would be misleading when polling non-element conditions (URL changes, text content).
- **`browser.ts` helper type `ClickTextOptions` is not exported**: It's an implementation detail of the BrowserAPI interface, only used as a parameter type. Callers construct it as an object literal — exporting would suggest it's meant to be referenced by name.
- **Magic numbers in `TIMINGS` constants**: Values like `3000`, `5000`, `10000` in task timing constants are empirical — they were tuned against the real sites. Naming them more descriptively (e.g., `SLOW_PAGE_LOAD`) wouldn't add clarity since the appropriate delay depends on the site's behavior, not on a category.
- **`vault/core.ts` string template for SQL**: The query strings use template literals with `$paramName` placeholders (not JS interpolation). This is safe — node:sqlite uses parameterized queries. Don't flag as SQL injection risk.
- **Extension `log()` function is minimal**: It's a `console.log` wrapper with a prefix. Don't suggest replacing with a logging library — this runs in a Chrome service worker where simplicity matters more than features.
- **`browser.ts` method named `type` clashes with TS keyword culture**: `type` is the standard name used by Playwright and Puppeteer. Renaming would confuse anyone coming from those frameworks.
- **`cdpClickSelector` naming compounds mechanism and input strategy**: Matches the established `cdp` + action pattern used by `cdpClick`. The name clearly signals "CDP click, resolved by selector."
- **`stepFailed` flag in `step-runner.ts` is redundant with pointer check**: Explicit and easy to read. The redundancy makes intent clear — "don't advance on failure" is stated directly rather than inferred from pointer state.
- **`clickSignIn` in nandosOrder.ts uses CDP click on submit button**: Nandos sign-in page is not behind a Cloudflare challenge — the Turnstile handling only appears on certain pages. CDP click works here and is intentional.
- **`PingCommand` and `GetUrlCommand` are manually typed instead of schema-derived**: Their schemas are `z.object({})` which infers to `Record<string, never>` — combining this with `& { type: "ping" }` creates an impossible type because the `type` key conflicts with the `never` index signature. Manual typing is correct here.
- **`getReconnectDelay` in `connection.ts` has an intermediate variable**: One line — the extra variable makes debugging easier (breakpoint on the return). Inlining saves nothing meaningful.
- **`needs` is explicit, not derived from `contextSchema`**: An earlier approach silently derived `needs` from `contextSchema` keys when `needs` was omitted. This was reverted because it's a hidden side effect — defining a schema shouldn't silently configure vault loading. The `contextSchema` validates shape/types; `needs` maps vault keys. They overlap in the common case but serve different purposes. Use `needsFromSchema(schema)` to reduce repetition explicitly: `needs: needsFromSchema(contextSchema)`.
- **`StepUpdate.state` includes "idle"**: The "idle" state in the overlay's `StepUpdate` type is the overlay's initial rendering state before any step update arrives from StepRunner. StepRunner never emits "idle" — it's a client-side-only concept for the overlay's pre-update display. Removing it would leave the overlay with no state before the first step begins.
- **`PrefixLogger` and `StepLogger` have different interfaces**: `PrefixLogger` has `.log()/.warn()/.error()/.success()` while `StepLogger` has `.log()/.warn()/.success()/.fatal()`. These serve different contexts — framework-level logging vs step-scoped logging with structured failure semantics. Unifying them would compromise the step logger's purpose-built API.
- **Gate double-await pattern in `step-runner.ts`**: `await this.gate.wait(); await this.gate.wait();` looks redundant but is correct. The first wait blocks until the gate opens (play). The second wait handles the case where the gate closes again immediately (pause between steps). Both awaits are needed for the pause/play/skip control flow.
- **Infinite retry loop in `run.ts`**: `while (true)` in `runWithRetry` is intentional. The task is designed to keep retrying until success or a fatal (non-StepError) error. StepErrors are expected failures (site not available, element not found) — the framework logs them and tries again after a configurable interval. A max-retry limit would defeat the monitoring purpose.
- **`terminate` vs `close` naming in `browser.ts`**: `close()` cleanly shuts down the WebSocket server. A separate `terminate()` for force-close was suggested but isn't needed — `close()` already handles the shutdown path, and there's no scenario where a graceful close fails that a force-terminate would solve.
- **`pollUntil` doesn't expose `lastValue` on timeout**: When `pollUntil` times out, it throws without returning the last polled value. The caller typically only cares about success (the resolved value) or failure (the timeout). Adding `lastValue` to the error would complicate the API for a debugging-only benefit — callers can log intermediate values in their poll function if needed.
- **No schema version in vault SQLite**: The vault schema is created by `initSchema()` and has no version column or migration system. The schema is simple (4 tables) and changes infrequently. A version/migration system would add complexity disproportionate to the schema's stability. If a breaking change is needed, a fresh vault can be created.
- **`resolveAdminAuth` silently clears invalid tokens from `.env`**: When `VAULT_ADMIN` contains a wrong-type token (32-byte project token instead of 48-byte session token) or an expired session, `resolveAdminAuth` removes it from `.env` and falls back to password prompt. This is intentional self-healing — the stderr message explains what happened, and re-prompting is better UX than failing with an opaque error.
- **Unicode checkmarks in logging output**: `PrefixLogger.success()` uses `✓` and other formatters use Unicode symbols. These display correctly in Docker logs, terminal output, and CI. ASCII alternatives would be less readable.
- **`send()` dual guard in `browser.ts`**: `send()` has both a `readyState` guard and a `try/catch` — these serve different purposes. The early guard rejects cheaply without registering a pending command. The try/catch handles errors after registration. Both are needed.
- **`stepRunnerDeps()` arrow-wraps methods**: Standard JS pattern — arrow functions preserve `this`. Commenting it would be like commenting `const x = 1`.
- **`StepErrorMeta` extends `Record<string, unknown>`**: Flexibility is intentional for task-specific metadata. Narrowing would require updating the type every time a task wants new debug fields.
- **`resolveToken` naming overlaps with `path.resolve`**: Different contexts (path resolution vs token lookup). No real ambiguity in practice.
- **All project schemas in one file (`schemas.ts`)**: Only 2 schemas today. Splitting into per-project files is premature until there's actual conflict.
- **`promptConfirm` auto-approves in non-TTY mode**: Intentional for scripting/automation. The alternative (failing in non-TTY) would make the CLI unusable in pipelines.
- **`setEnvVar` splits on `\n` without handling `\r\n`**: macOS/Linux only tool. `.env` is created and maintained by this same code, so line endings are always `\n`.
- **Two private `logAt` closures with different signatures in `logging.ts`**: Completely different scopes (`createTaskLogger` vs `createPrefixLogger`), 50 lines apart in different factory functions. No real risk of confusion.
- **`needsFromSchema` silently returns `{}` for non-ZodObject schemas**: A non-ZodObject schema would also fail `contextSchema` validation at runtime with a clear error. Adding a throw would create a duplicate error path. Current behavior is safe.
- **`loader.ts` error says `.ts` but loader resolves `.js`**: The `.ts` extension in the error message is correct — tells contributors where to create the source file. The loader finds the compiled `.js`. Showing `.js` would confuse source-file seekers.
- **Module-level `WS_PORT` validation throws before `main()` in `run.ts`**: Must happen at module scope because `WS_PORT` is a constant used elsewhere. Moving into `main()` would require threading as a parameter. Error is clear and actionable.
- **`attempt` initialized to 0, immediately `++` to 1 in `run.ts`**: `while(true) { attempt++; ... }` is idiomatic for "attempt starts at 1, increments each iteration." Established pattern.
- **Redundant `if (elements)` guards in `extension/overlay/controls.ts`**: TypeScript's control flow analysis doesn't narrow module-level variables across function calls. Without the guards, `elements.foo` is a type error. Guards are required by the type checker, not redundant.
- **`SAFE_MODE` env var in `nandosOrder.ts`**: Safety valve for dev/testing — prevents accidentally placing a real food order. Task-level feature flag, not infrastructure. Not the same as dev/prod environment separation. Threaded via `--safemode` CLI flag → `SAFE_MODE` env var → Docker compose → task.
- **`TIMINGS` has 14 keys; single-use ones could be local in `nandosOrder.ts`**: All timing values at the top in one place makes them easy to find and tune together. Scattering into functions would require searching. Correct approach for empirical constants.
- **`formatTime` helper in `extension/logging.ts` only called once**: 3 lines of date formatting. Inlining into `log()` would reduce readability. Extracting small formatting helpers is standard.
- **No `blur` event after fill in `extension/messages/commands/fill.ts`**: Adding `blur` would change behavior for all sites. Current sequence (focus → value → input → change) works. Speculatively adding it risks unwanted side effects. If needed, add as an option per-command.
- **Async guard in `vault/db.ts` is runtime-only; could be compile-time**: TypeScript's `Exclude` on return types is fragile with confusing error messages. Runtime guard gives clear, actionable error (`"callback must be synchronous — got a Promise"`). Intentional defense-in-depth.
- **`withVault`/`withVaultReadOnly` have duplicated structure in `vault/cli/env.ts`**: Two functions, 8 lines each, differ only in the opener call. A shared helper would save 4 lines but add indirection. Tolerable at this scale.

- **String-based step names**: The old `StepRunner.step("name", fn)` API required manually keeping step names in sync with function names. Replaced with `step(fn, ...args)` which auto-derives the name from `fn.name`, and `named(subtitle, fn, ...args)` for reused functions. Anonymous arrows are rejected at runtime. The old string-based API is no longer available.
- **`handleSuccess` splitting in `run.ts`**: Three side effects (log, file write, bell) are sequential in a 15-line function. Splitting into separate functions would add definitions for a linear sequence with no branching.
- **`normalizeUrl` inside `handleGetFrameId`**: 5-line helper called once, two lines below its definition. Hoisting to module level separates it from its only consumer. Tightly-scoped placement is standard.
- **`verifyLogin` after `handleMfa` in `nandosOrder.ts`**: Defensive redundancy — costs one `getUrl()` call and catches edge cases if `handleMfa`'s poll has a subtle bug. Intentional safety.
- **Error tests separated from happy path in `browser.test.ts`**: The `describe("Error scenarios")` block groups related error tests for quick scanning. Both collocated and separated approaches are valid.

- **`npm run vault` always rebuilds TypeScript**: Every vault CLI command runs `npm run build` first (`package.json`). For read operations like `vault detail list` this is wasteful (~5-10s). Considered `vault:dev` using `jiti` or conditional builds, but: vault CLI tests run against `dist/` (stale code is the worse failure mode), `jiti` doesn't work for all vault code paths, and the rebuild catches type errors early. The overhead is tolerable for a personal tool with infrequent vault operations.

- **Defaulting `needs` to `[]` in task config**: Requiring `needs: []` explicitly when a task needs no vault data documents the intent ("I checked and this task needs nothing"). Defaulting to `[]` makes vault loading opt-in, which hides the fact that the decision was made. Tasks that use the vault should require `needs`, and explicitly writing `needs: []` for vault-free tasks is a one-line cost for clear intent. Use `needsFromSchema(schema)` to derive needs when a schema exists.
- **Consolidating `pollUntil` across `browser/poll.ts` and `projects/utils/poll.ts`**: The two implementations are intentionally separate. They serve different modules with different needs: browser's version returns `{ ok: false }` on timeout (simpler, internal use), projects' version returns `{ ok: false, timeoutMs }` (task callers use `timeoutMs` in error messages) and validates `intervalMs > 0`. Different sleep imports (`node:timers/promises` vs `timing.ts`) reflect the module boundary. Consolidating would create a cross-module dependency for no benefit.
- **Exporting `BrowserAPI` sub-interfaces (`BrowserNavigation`, `BrowserClicking`, etc.)**: Tasks receive `BrowserAPI` and pass the whole thing. No helper functions need a subset. Exporting would add 7 types to the public surface for a hypothetical use case.
- **Unifying `waitForText` (accepts `string[]`) and `waitForUrl` (accepts `string`)**: Different use cases: text matching needs alternatives ("Order confirmed" vs "Thank you") because sites vary. URL matching is against a known path fragment. Adding array support to `waitForUrl` would be over-engineering.
- **Adding error field to `CdpClickSelectorResult`**: CDP click recovers by coordinate — it doesn't need error details on failure. `SelectorResult` has `error` because DOM click callers use it for diagnostics. The types serve different callers with different needs.
- **Extracting `xpathString` from `click-text.ts` injected function**: The function must run in the page context because it constructs XPath expressions that depend on the page's XPath engine. Pre-building XPath strings on the host side would mean building and passing complex strings — more brittle than the current approach. The function handles a well-known XPath quoting edge case (mixed apostrophes and quotes).
- **`cdpClickSelector` zero-area guard `||` vs `&&` comment**: The condition `width <= 0 || height <= 0` is straightforward. Commenting `||` vs `&&` on a simple guard is over-commenting.
- **`stepRunnerDeps()` short-circuit `&&` with spread for conditional `pauseOnError`**: Idiomatic JS pattern. The variable name `pauseOnError` is self-documenting.
- **`close()` comment mentions "close handler" but code calls `ws.terminate()`**: `terminate()` fires the `close` event in the `ws` library, so the comment is accurate about the handler being involved.
- **`charToKeyCode` fallback for non-ASCII returns wrong code silently in `keyboard.ts`**: Only used with known key names and ASCII characters. Non-ASCII input is not a supported use case for CDP key dispatch.
- **`ensureConnection()` throws synchronously in `send()` (browser.ts:232)**: `send()` returns `new Promise(...)` (not `async`), so `ensureConnection()` throws synchronously rather than rejecting. All call sites `await` the result, so the caller's `async` function catches it. The scenario requiring a rejection (storing the Promise without awaiting) doesn't exist.
- **Second WebSocket connection silently overwrites `this.ws` (browser.ts:169)**: Docker runs one Chrome instance with one extension. A second connection can't happen in the current architecture.
- **`handleSuccess` `writeFileSync` uncaught in `run.ts:97`**: If the log volume can't be written to, something is seriously wrong with the Docker setup. A loud failure is the right signal.
- **`logStream` never explicitly closed in `run.ts:221`**: Node.js handles stream cleanup on exit. The process exits immediately after `main()`. Explicit cleanup adds ceremony for zero practical benefit.
- **`task.intervalMs` fallback not range-checked in `run.ts:130`**: Task authors are the only consumers and they set reasonable values. The 2-task codebase uses 300_000ms (5 minutes). Over-validating internal constants adds noise.
- **`log.success("No turnstile found")` in `botcLogin.ts:69`**: `success` makes the log output easy to scan. "No obstacle found" is a positive outcome from the step's perspective.
- **`dumpHtml` `writeFile` uncaught in `dump.ts:19`**: This is a debugging tool called intentionally. If it fails, the developer should know immediately rather than having the failure hidden in a warning.
- **`SAFE_MODE` case-sensitive check in `nandosOrder.ts:49`**: The env var is set programmatically by `check.ts` (always `"true"`) and never typed by hand. Case sensitivity is fine for machine-set values.
- **Double-label prompt in `project setup` (project.ts:139-140)**: `console.error` followed by `promptHidden("Value")` shows two labels for one input. Both labels together provide redundant context, which some users may find helpful. Not confusing enough to warrant refactoring `getSecretValue`.
- **`DEFAULT_TIMEOUT_MS` 10000 vs navigate's 30000 undocumented in `wait-for-selector.ts`**: Different operations have different defaults. Documenting every constant difference adds noise.
- **`to`/`by` scroll modes use a boolean flag in `scroll.ts`**: Only two modes. A string discriminant for two values is premature.
- **Race window between `waitForTabLoad` and `chrome.tabs.update` in `navigate.ts`**: Listener is registered before `update` — correct ordering. The edge case is a Chrome API limitation that can't be fixed.
- **`hasKey` helper is generic but called once in `messages/index.ts`**: Provides proper type narrowing (`key is Extract<keyof T, string>`). Inlining would lose this narrowing or require a cast.
- **`ResponseFor` utility type not in README**: Internal type used only in `browser.ts`. Not part of the task-author API.
- **Emoji button labels hardcoded in `overlay/dom.ts`**: Display text, not logic. `ControlAction` types are enforced by TypeScript.
- **Tab listener fires for all tabs, `changedTabId === tabId` check in `tabs.ts`**: Only one tab is used, but the check is still needed because Chrome fires the event for all tabs. The guard is correct and trivially cheap.
- **`getFrameId` exact URL match could miss query param differences**: Exact match is correct for current use cases (iframe `src` attributes don't typically differ by query params from Chrome's frame list). A comment documents the limitation and the fuzzy-matching alternative if needed later.
- **`extractResult` returning generic "Script did not execute" for both missing-frame and navigation cases**: The two causes are indistinguishable at the API level (`results[0]?.result` is `undefined` in both cases). Adding a heuristic would be fragile. A comment now documents the dual meaning.
- **`StepUpdateMessage` and `StepState` field names (`current`/`total`/`name`)**: Names are correct and consistent with `StepRunner` emissions. `current`/`total` clearly convey index-of-total semantics. No rename needed.
- **`validateContext` Zod `.message` output in `tasks.ts`**: Fires once at startup. The full Zod error message includes all issues with paths and is already actionable. `.flatten()` loses nested path info.
- **`loadTask` second directory scan on error path in `loader.ts`**: Error path performance is irrelevant (process exits). The second `listTaskNames()` call builds a helpful "available tasks" list for the error message.
- **`getProjectNeeds` iterates all tasks in `loader.ts`**: 2-10 tasks total. Performance note for a microsecond operation is premature.
- **`writeLog`/`output` two-level indirection in `run.ts`**: The existing comment explains the upgrade pattern (console-only at startup, tee'd to file once task name is known). The indirection is 2 lines.
- **`shouldKeepOpen` extracted as named predicate in `run.ts`**: Named predicates make `if` statements read like prose. Inlining saves one function but loses readability. Standard clean-code pattern.
- **`Readonly<StepState>` annotation in `logging.ts`**: The `let state = createStepState()` with `state = formatLogLine(...)` is idiomatic functional-update-via-reassignment. Adding `Readonly<>` adds type noise for a 40-line function where the pattern is obvious. The same `let` + reassignment pattern is used for `lastTime` in `createPrefixLogger` — applying `Readonly` inconsistently would be worse.
- **Merging `emitUpdate`/`emitErrorUpdate` in `step-runner.ts`**: Both methods are short (9 lines) and self-contained. The `Math.min` clamping difference is intentional — error updates happen mid-run (pointer valid), "done" updates happen past-end (needs clamping). Merging saves 8 lines but obscures the clamping rationale.
- **Renaming `deps` parameter in `TaskRun` type or passing pre-constructed `StepRunner`**: The type name `StepRunnerDeps` is already descriptive. Renaming the parameter to `stepRunnerDeps` is cosmetic (one line per task). Passing a pre-constructed `StepRunner` splits lifecycle ownership (framework creates, task registers steps) and makes tests depend on the concrete class instead of a plain interface.
- **`rebuild` suppresses `--build` without comment in `check-args.ts`**: The variable name `shouldBuild` and the condition `!opts.noBuild && !opts.rebuild` are self-explanatory. The mutual-exclusivity guard (Will #11) already makes this interaction explicit.
- **`EMPTY_TREE_HASH` unexported in `check-args.ts`**: Well-known SHA256 constant. Exporting for a single test assertion isn't worth the API surface increase. Tests verify behavior, not internal constants.
- **`let opts` before try/catch in `check.ts`**: Standard TypeScript pattern for try/catch initialization. `process.exit(1)` in catch guarantees assignment. An IIFE adds nesting for no clarity gain.
- **Module-level side effects in `infra/run.ts`**: Docker container entrypoint — not importable in tests. `process.env` mutation needed before Xvfb spawn; current ordering is correct.
- **`handleExit` naming in `infra/run.ts`**: Communicates "this is what happens when we exit." Both signal-triggered and imperative exits run the same cleanup. `teardown` is equally valid but no clearer.
- **`timeout` parameter lacks unit suffix in `infra/run.ts`**: Private function, called once, with constant named `READINESS_TIMEOUT`. Unit is clear from context.
- **Private logger functions in `infra/run.ts`**: Completely separate file from framework logging. File location already separates contexts. No cross-imports.
- **Port 8765 undocumented in `Dockerfile`**: Compose file maps the port with purpose clear from context. Low-value comment.
- **`SOURCE_HASH` cache-busting comment in `Dockerfile`**: Well-known Docker pattern. Expanding the comment would explain Docker fundamentals, not project-specific logic.
- **`SCREEN_SIZE`/`LOG_DIR` absent from compose environment**: Code-level defaults exist. Adding to compose creates a second source of truth.
- **`restart: "no"` explicit in `docker-compose.yml`**: The explicit value IS the comment — signals intentional choice, not oversight.
- **`LOG_DIR` host vs container path in `infra/README.md`**: README shows host-side perspective (`logs/`), code runs inside container (`/app/logs`). Both correct for their context.
- **`waitForFirst` error array index coupling in `selectors.ts`**: `Promise.any` preserves insertion order for `errors` — well-defined JS behavior. The coupling is correct.
- **`fillFirst` has no JSDoc in `selectors.ts`**: One-line function that delegates to `waitForFirst` + `browser.fill`. Self-explanatory from the code.
- **`TURNSTILE_SELECTORS` has no extensibility comment in `turnstile.ts`**: Self-explanatory CSS selectors. A new project author would naturally extend the array.
- **`pollUntil` zero `timeoutMs` edge case in `projects/utils/poll.ts`**: The `intervalMs > 0` guard prevents busy-loops. Zero `timeoutMs` is a caller error, not a poll edge case.
- **`pollUntil` `@throws` not documented in JSDoc in `projects/utils/poll.ts`**: The throw is the first line of the function with a clear message. JSDoc `@throws` for a one-line validation guard is over-documenting.
- **`sleep` re-export hides `setTimeout` overloads in `timing.ts`**: Tasks only need `sleep(ms)`. The alias correctly narrows the interface.
- **`LOGS_DIR` three-level `../` in `dump.ts`**: Standard resolution pattern, same as `run.ts`. Stable path.
- **Closure capture pattern undocumented in task files**: Both tasks demonstrate it identically. New tasks are created by copying existing ones. (Most closure variables eliminated — `FINAL_STEP` and `finalUrl` removed; framework captures URL automatically.)
- **`skipLogin` lazy closure in `nandosOrder.ts`**: Standard JS closure over `let` variable. Declaration and mutation visible within a few lines.
- **`tryDismissSuggestions`/`dismissSuggestions` two-layer naming in `nandosOrder.ts`**: Standard extract-and-wrap pattern. `try` prefix signals "returns success/failure."
- **Bare `sleep(TIMINGS.modalWait)` calls in `nandosOrder.ts`**: Constant name `modalWait` and surrounding context make purpose clear.
- **`run()` step blocks lack section markers in `nandosOrder.ts`**: Step names ARE the section markers. Each `.step()` call is a clear visual boundary.
- **`navigateToCategory` no explicit timeout in `nandosOrder.ts`**: Default timeout adequate. Over-specifying adds noise.
- **`URLS` object undocumented in `nandosOrder.ts`**: One-key object, purpose obvious from usage.
- **`unpackBlob` has no layout comment in `crypto.ts`**: Offsets are derived from named constants (`IV_LENGTH`, `AUTH_TAG_LENGTH`). The layout is readable from the code. `packBlob` is equally self-documenting — the concatenation order is the layout.
- **`exportProjectToken`/`parseProjectToken` inverse pair not documented in `crypto.ts`**: Function names clearly indicate the relationship (export/parse).
- **Low-level AES functions exported alongside high-level helpers in `crypto.ts`**: All exports are used by `core.ts` and `ops/`. No external callers exist. The module has a clear internal audience.
- **`wrapVaultOpenError` exported solely for test access in `core.ts`**: Tests need to verify error wrapping behavior. The export is harmless — no external consumers of the vault package.
- **`changePassword` inline comment about session wiping in `core.ts`**: The comment is at the relevant code line. Moving it to the function level separates it from the code it explains.
- **`withSavepoint` error doesn't say what characters are allowed in `db.ts`**: The regex `[a-zA-Z_]` is visible 2 lines above. Error messages don't need to duplicate the validation rule.
- **Error messages lack table/operation context in `rows.ts`**: Callers add context via their own error handling. Adding table context to low-level field extractors would require threading parameters.
- **`createProject` has no savepoint in `projects.ts`**: Single INSERT is atomic. Adding a savepoint for a single statement is unnecessary.
- **`renameProject` comment omits FK name in `projects.ts`**: The comment explains the workaround clearly. The specific FK name is an implementation detail.
- **`getProjectKey` "master key mismatch" error after password verification in `projects.ts`**: The error covers both mismatch and corruption. After password change, the old master key genuinely doesn't match. The message is accurate.
- **Two-stage decryption loop has no structural comment in `runtime.ts`**: The try/catch blocks have clear error messages. The structure is self-documenting.
- **`createSession` prunes expired sessions as undocumented side effect in `sessions.ts`**: Housekeeping during creation is a common pattern. The pruning is visible in the function body.
- **`getMasterKeyFromSession` "not found" error has no recovery hint in `sessions.ts`**: Adding recovery hints to every error message creates coupling between ops and CLI layers. The CLI can add hints at its level.
- **`VAULT_PATH` three-level `../` assumption in `env.ts`**: Standard pattern for resolving from compiled output to project root. The path is stable.
- **`rl.question("")` with empty string in `prompt.ts`**: The label is written to stderr on the preceding line. The empty string prevents double-printing. Standard readline pattern.
- **Module-level `stdinBuffer`/`stdinIndex` state in `prompt.ts`**: The vault CLI is tested via `spawnSync` (separate process). The module-level state is fine for CLI use.
- **Auth required for `detail list` is implicit policy in `detail.ts`**: The auth call is the first line of the handler. Its presence IS the documentation of the policy.
- **`handleChangePassword` "old password" prompt labeled "Vault password" in `session.ts`**: The flow is old → new → confirm. "Vault password" is unambiguous in context — it's the first prompt.
- **`deriveMasterKeyWithSalt` vs `deriveMasterKey` redundant wrapper in `core.ts`**: `deriveMasterKey` is the common-case helper. `deriveMasterKeyWithSalt` is used by `changePassword` which needs both. The naming indicates the relationship.
- **`createDeps` factory name in `step-runner.test.ts`**: The function creates deps, not a runner. Callers construct the runner themselves. The name is accurate.
- **`setupRawTaskTest` vs `setupTaskRunTest` naming in `test-helpers.ts`**: The names reflect different abstraction levels. `Raw` signals "bring your own responder."
- **`state` mutability signal in `createDefaultResponder` in `test-helpers.ts`**: `state` as a mutable container is a standard pattern. The destructuring `{ responder, state }` makes the return clear.
- **`changePassword` test isolation via `beforeEach` rollback in `vault.test.ts`**: The test isolation is correct. The `beforeAll`/`beforeEach` pattern is visible at the top of the file.
- **Key comment placement in `loader.test.ts`**: The comment is between imports and `beforeEach` — a natural reading position. Moving to top-of-file separates it from the code it explains.
- **"Attach rejection handler" comment not replicated in `browser.test.ts`**: Other tests using the same pattern don't need the comment — the pattern is established by this first instance.
- **Module-level `attemptCount` in `retry-task.ts`**: `resetAttempts()` is called in `beforeEach`. The reset function's existence documents the need.
- **Fake timers scoped globally in `dump.test.ts`**: All three tests write timestamped filenames. Fake timers ensure deterministic filenames across all tests.
- **`neverResolves` in shared `test-helpers.ts` used by one test**: One import from a shared fixtures file. Moving adds a file for one export. Available for future tests that need it.
- **`sessions.id` blob storage vs external base64 representation in `schema.ts`**: Standard binary-storage / text-transport pattern. `createSession` encodes to base64, `parseSessionToken` decodes back. No mismatch, no effects.
- **`details` INSERT column order differs from PRIMARY KEY in `schema.ts`**: INSERT lists `key, project` matching the CREATE TABLE column declaration order. PRIMARY KEY `(project, key)` controls B-tree index layout, not INSERT ordering. SQLite matches by name.

- **Block comment style in `browser.ts:437-442`**: The `close()` method uses a `/* */` block comment while the rest of the file uses `//`. Using `/* */` for multi-sentence explanations and `//` for single-line annotations is a common, readable convention. The block comment visually signals "this is a paragraph of explanation."
- **`resolveToken` silently falls back from project-specific to generic `VAULT_TOKEN` in `run.ts:53-63`**: The fallback (`process.env[envKey] ?? process.env.VAULT_TOKEN`) is intentional — single-project setups use `VAULT_TOKEN`, multi-project setups use project-specific vars. The error message (when neither exists) documents both env var names. Logging which token was used would add noise to every successful run.

## Failed Approaches

### Cloudflare Bypass

All approaches below share one fatal flaw: **they all use CDP to control the browser**. Cloudflare detects CDP through `navigator.webdriver`, missing/modified `window.chrome` properties, CDP-specific JS execution patterns, TLS fingerprint differences, and network request timing.

**What actually works**: Chrome Extension (runs as normal JS, no automation protocol) communicating via WebSocket.

1. **Playwright with Stealth Plugin** — Still detected. Stealth plugin hides some automation markers but CDP connection is still detectable.
2. **Installed Chrome instead of bundled Chromium** — Still detected. The browser executable doesn't matter — CDP connection is the issue.
3. **Chrome persistent context (user profile)** — Still detected. Even with real cookies/history, CDP connection gives it away.
4. **Firefox via Playwright** — Failed. Playwright's Firefox is a modified Nightly build; system Firefox can't be used (requires Juggler protocol).
5. **rebrowser-patches** — Patch failed, incompatible with Playwright 1.58.1.
6. **Human-like behavior simulation** (random mouse movements, typing delays, scroll patterns) — Still detected. Behavioral simulation doesn't help if CDP connection is already flagged.
7. **`--disable-blink-features=AutomationControlled`** — Still detected. This flag is well-known and Cloudflare checks for more.
8. **Custom User Agent** — Still detected. Easy to spoof but CDP connection is still there.

### Architecture

9. **Remote code execution via `unsafe-eval` CSP** — Extension loads fine with this CSP, but rejected because: debugging is harder (opaque stack traces), no type safety (code strings bypass TS), marginal benefit (primitive-based approach already achieves clean separation), security surface (`unsafe-eval` is a code smell), and maintenance burden (DOM code as strings is harder to refactor).

10. **Host-side polling for `waitForSelector`** — Replace in-page polling with host-side WebSocket round-trips. Rejected because: latency doubles (20-50ms per hop), WebSocket traffic scales with timeout (50x more messages for 10s wait), navigation during `waitForSelector` is a task design bug (not a primitive issue), current error is actionable, and a simpler fix (beforeunload listener) is available if needed.

11. **Connection status chip in debug overlay** — Rejected because: requires cross-context messaging (content script ↔ service worker), connection failures are already loud (`Browser.start()` throws), Docker is single-tab (no ambiguity about which endpoint), and the service worker console already logs connection state.
