# Rejected: Framework

Won't-fix decisions for `stack/framework/`. Check before proposing changes to step-runner, run.ts, logging, tasks, loader, or check.

- **`stepFailed` flag in `step-runner.ts` is redundant with pointer check**: Explicit and easy to read. The redundancy makes intent clear — "don't advance on failure" is stated directly rather than inferred from pointer state.
- **`needs` is explicit, not derived from `contextSchema`**: An earlier approach silently derived `needs` from `contextSchema` keys when `needs` was omitted. This was reverted because it's a hidden side effect — defining a schema shouldn't silently configure vault loading. The `contextSchema` validates shape/types; `needs` maps vault keys. They overlap in the common case but serve different purposes. Use `needsFromSchema(schema)` to reduce repetition explicitly: `needs: needsFromSchema(contextSchema)`.
- **`PrefixLogger` and `StepLogger` have different interfaces**: `PrefixLogger` has `.log()/.warn()/.error()/.success()` while `StepLogger` has `.log()/.warn()/.success()/.fatal()`. These serve different contexts — framework-level logging vs step-scoped logging with structured failure semantics. Unifying them would compromise the step logger's purpose-built API.
- **Gate double-await pattern in `step-runner.ts`**: `await this.gate.wait(); await this.gate.wait();` looks redundant but is correct. The first wait blocks until the gate opens (play). The second wait handles the case where the gate closes again immediately (pause between steps). Both awaits are needed for the pause/play/skip control flow.
- **Infinite retry loop in `run.ts`**: `while (true)` in `runWithRetry` is intentional. The task is designed to keep retrying until success or a fatal (non-StepError) error. StepErrors are expected failures (site not available, element not found) — the framework logs them and tries again after a configurable interval. A max-retry limit would defeat the monitoring purpose.
- **`pollUntil` doesn't expose `lastValue` on timeout**: When `pollUntil` times out, it throws without returning the last polled value. The caller typically only cares about success (the resolved value) or failure (the timeout). Adding `lastValue` to the error would complicate the API for a debugging-only benefit — callers can log intermediate values in their poll function if needed.
- **Unicode checkmarks in logging output**: `PrefixLogger.success()` uses checkmarks and other formatters use Unicode symbols. These display correctly in Docker logs, terminal output, and CI. ASCII alternatives would be less readable.
- **`stepRunnerDeps()` arrow-wraps methods**: Standard JS pattern — arrow functions preserve `this`. Commenting it would be like commenting `const x = 1`.
- **`StepErrorMeta` extends `Record<string, unknown>`**: Flexibility is intentional for task-specific metadata. Narrowing would require updating the type every time a task wants new debug fields.
- **`needsFromSchema` silently returns `{}` for non-ZodObject schemas**: A non-ZodObject schema would also fail `contextSchema` validation at runtime with a clear error. Adding a throw would create a duplicate error path. Current behavior is safe.
- **`loader.ts` error says `.ts` but loader resolves `.js`**: The `.ts` extension in the error message is correct — tells contributors where to create the source file. The loader finds the compiled `.js`. Showing `.js` would confuse source-file seekers.
- **Module-level `WS_PORT` validation throws before `main()` in `run.ts`**: Must happen at module scope because `WS_PORT` is a constant used elsewhere. Moving into `main()` would require threading as a parameter. Error is clear and actionable.
- **`attempt` initialized to 0, immediately `++` to 1 in `run.ts`**: `while(true) { attempt++; ... }` is idiomatic for "attempt starts at 1, increments each iteration." Established pattern.
- **String-based step names**: The old `StepRunner.step("name", fn)` API required manually keeping step names in sync with function names. Replaced with `step(fn, ...args)` which auto-derives the name from `fn.name`, and `named(subtitle, fn, ...args)` for reused functions. Anonymous arrows are rejected at runtime. The old string-based API is no longer available.
- **`handleSuccess` splitting in `run.ts`**: Three side effects (log, file write, bell) are sequential in a 15-line function. Splitting into separate functions would add definitions for a linear sequence with no branching.
- **`normalizeUrl` inside `handleGetFrameId`**: 5-line helper called once, two lines below its definition. Hoisting to module level separates it from its only consumer. Tightly-scoped placement is standard.
- **`npm run vault` always rebuilds TypeScript**: Every vault CLI command runs `npm run build` first (`package.json`). For read operations like `vault detail list` this is wasteful (~5-10s). Considered `vault:dev` using `jiti` or conditional builds, but: vault CLI tests run against `dist/` (stale code is the worse failure mode), `jiti` doesn't work for all vault code paths, and the rebuild catches type errors early. The overhead is tolerable for a personal tool with infrequent vault operations.
- **`validateContext` Zod `.message` output in `tasks.ts`**: Fires once at startup. The full Zod error message includes all issues with paths and is already actionable. `.flatten()` loses nested path info.
- **`loadTask` second directory scan on error path in `loader.ts`**: Error path performance is irrelevant (process exits). The second `listTaskNames()` call builds a helpful "available tasks" list for the error message.
- **`getProjectNeeds` iterates all tasks in `loader.ts`**: 2-10 tasks total. Performance note for a microsecond operation is premature.
- **`writeLog`/`output` two-level indirection in `run.ts`**: The existing comment explains the upgrade pattern (console-only at startup, tee'd to file once task name is known). The indirection is 2 lines.
- **`shouldKeepOpen` extracted as named predicate in `run.ts`**: Named predicates make `if` statements read like prose. Inlining saves one function but loses readability. Standard clean-code pattern.
- **`Readonly<StepState>` annotation in `logging.ts`**: The `let state = createStepState()` with `state = formatLogLine(...)` is idiomatic functional-update-via-reassignment. Adding `Readonly<>` adds type noise for a 40-line function where the pattern is obvious. The same `let` + reassignment pattern is used for `lastTime` in `createPrefixLogger` — applying `Readonly` inconsistently would be worse.
- **Merging `emitUpdate`/`emitErrorUpdate` in `step-runner.ts`**: Both methods are short (9 lines) and self-contained. The `Math.min` clamping difference is intentional — error updates happen mid-run (pointer valid), "done" updates happen past-end (needs clamping). Merging saves 8 lines but obscures the clamping rationale.
- **Renaming `deps` parameter in `TaskRun` type or passing pre-constructed `StepRunner`**: The type name `StepRunnerDeps` is already descriptive. Renaming the parameter to `stepRunnerDeps` is cosmetic (one line per task). Passing a pre-constructed `StepRunner` splits lifecycle ownership (framework creates, task registers steps) and makes tests depend on the concrete class instead of a plain interface.
- **`rebuild` suppresses `--build` without comment in `check-args.ts`**: The variable name `shouldBuild` and the condition `!opts.noBuild && !opts.rebuild` are self-explanatory. The mutual-exclusivity guard (Will #11) already makes this interaction explicit.
- **`EMPTY_TREE_HASH` unexported in `check-args.ts`**: Well-known SHA256 constant. Exporting for a single test assertion isn't worth the API surface increase. Tests verify behavior, not internal constants.
- **`let opts` before try/catch in `check.ts`**: Standard TypeScript pattern for try/catch initialization. `process.exit(1)` in catch guarantees assignment. An IIFE adds nesting for no clarity gain.
- **Two private `logAt` closures with different signatures in `logging.ts`**: Completely different scopes (`createTaskLogger` vs `createPrefixLogger`), 50 lines apart in different factory functions. No real risk of confusion.
- **`handleSuccess` `writeFileSync` uncaught in `run.ts:97`**: If the log volume can't be written to, something is seriously wrong with the Docker setup. A loud failure is the right signal.
- **`logStream` never explicitly closed in `run.ts:221`**: Node.js handles stream cleanup on exit. The process exits immediately after `main()`. Explicit cleanup adds ceremony for zero practical benefit.
- **`task.intervalMs` fallback not range-checked in `run.ts:130`**: Task authors are the only consumers and they set reasonable values. The 2-task codebase uses 300_000ms (5 minutes). Over-validating internal constants adds noise.
- **`stepRunnerDeps()` short-circuit `&&` with spread for conditional `pauseOnError`**: Idiomatic JS pattern. The variable name `pauseOnError` is self-documenting.
- **`resolveToken` silently falls back from project-specific to generic `VAULT_TOKEN` in `run.ts:53-63`**: The fallback (`process.env[envKey] ?? process.env.VAULT_TOKEN`) is intentional — single-project setups use `VAULT_TOKEN`, multi-project setups use project-specific vars. The error message (when neither exists) documents both env var names. Logging which token was used would add noise to every successful run.
